import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { authenticateToken, validateUser, generateToken, authenticateSession } from "./middleware/auth";
import { shortenUrl, generateQrCode, getUrlAnalytics, addUtmParameters } from "./utils/linkyVicky";
import { generateLinkSuggestions, generatePerformanceInsights, generateLinkOrderRecommendations } from "./utils/openai";
import { 
  insertUserSchema,
  insertProfileSchema,
  insertLinkSchema,
  userAuthSchema,
  linkUpdatePositionSchema
} from "@shared/schema";
import session from "express-session";
import { z } from "zod";
import passport from "passport";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
import cors from "cors";
import path from "path";
import fs from "fs";

// Helper function to dump request info for debugging
function dumpRequestInfo(req: Request, title: string = 'Request Info') {
  console.log(`\n 🔍 ${title.toUpperCase()} 🔍`);
  console.log(`📍 URL: ${req.method} ${req.url}`);
  console.log(`🍪 Cookies: ${req.headers.cookie || 'None'}`);
  console.log(`🆔 Session ID: ${req.sessionID || 'None'}`);
  console.log(`👤 Session User ID: ${req.session?.userId || 'None'}`);
  console.log(`🔑 Authorization: ${req.headers.authorization ? 'Present' : 'None'}`);
  console.log(`📦 Session Data: ${JSON.stringify(req.session, null, 2) || 'None'}`);
}

export async function registerRoutes(app: Express): Promise<Server> {
  const httpServer = createServer(app);

  // Setup CORS - ensure it runs before session middleware
  app.use(cors({
    // Allow multiple origins (replit.app and custom domains)
    origin: function(origin, callback) {
      // For local development or testing without origin (like curl)
      if (!origin) return callback(null, true);
      
      // Allow replit domains and your custom domain (if any)
      const allowedOrigins = [
        'https://linkybecky.replit.app', 
        'https://linkybecky.com',
        'http://localhost:3000',
        'http://localhost:5173'
      ];
      
      if (allowedOrigins.indexOf(origin) !== -1 || process.env.NODE_ENV !== 'production') {
        callback(null, true);
      } else {
        console.warn(`⚠️ CORS blocked request from origin: ${origin}`);
        callback(null, true); // Still allow for now during debugging
      }
    },
    credentials: true, // Essential for cookies/auth to work cross-domain
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Cookie', 'X-Requested-With'],
    exposedHeaders: ['Set-Cookie'],
  }));
  
  // Add a middleware to add the proper headers for cookies
  app.use((req, res, next) => {
    // Ensure proper headers are set for cookies to work
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    next();
  });
  
  // Set up session middleware with improved cookie settings
  app.use(
    session({
      secret: process.env.SESSION_SECRET || "linky-becky-session-secret",
      resave: true, // Force session to be saved back to the store 
      saveUninitialized: true, // Save uninitialized sessions
      rolling: true, // Force cookie to be set on every response
      name: 'linkybecky.sid', // Custom cookie name to avoid conflicts
      cookie: { 
        // Always use secure cookies when in production
        secure: process.env.NODE_ENV === 'production', 
        httpOnly: true, // Prevent client-side JS from reading the cookie
        // Important: 'none' is needed for cross-domain cookies but requires secure: true
        // For Replit's environment with HTTPS, this is essential
        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
        path: '/', // Ensure cookie is available for all paths
        maxAge: 1000 * 60 * 60 * 24 * 7 // 1 week
      }
    })
  );

  // Initialize Passport
  app.use(passport.initialize());
  app.use(passport.session());
  
  // Configure Passport to serialize and deserialize user objects to/from session
  passport.serializeUser((user: any, done) => {
    console.log('Serializing user to session:', user?.id || user);
    // Store just the user ID in the session
    done(null, user.id || user);
  });
  
  passport.deserializeUser(async (id: number, done) => {
    console.log('Deserializing user from session ID:', id);
    try {
      // Lookup the user in the database based on the ID from the session
      const user = await storage.getUser(id);
      if (!user) {
        console.log('❌ User not found during deserialization:', id);
        return done(null, false);
      }
      console.log('✅ User deserialized successfully:', user.username);
      return done(null, user);
    } catch (err) {
      console.error('❌ Error deserializing user:', err);
      return done(err, null);
    }
  });
  
  // Debug middleware to log session and cookie data
  app.use((req, res, next) => {
    console.log('Debug - Session ID:', req.sessionID);
    console.log('Debug - Session data:', req.session);
    console.log('Debug - Cookies:', req.headers.cookie);
    next();
  });

  // Configure Google OAuth strategy
  if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
    passport.use(
      new GoogleStrategy(
        {
          clientID: process.env.GOOGLE_CLIENT_ID,
          clientSecret: process.env.GOOGLE_CLIENT_SECRET,
          callbackURL: process.env.NODE_ENV === "production" 
            ? "https://linkybecky.replit.app/api/auth/google/callback"
            : "/api/auth/google/callback"
        },
        async (accessToken, refreshToken, profile, done) => {
          try {
            console.log('🔍 Google OAuth processing for profile:', {
              id: profile.id,
              email: profile.emails?.[0]?.value,
              displayName: profile.displayName
            });
            
            // Check if user exists by Google ID
            let user = await storage.getUserByGoogleId(profile.id);
            if (user) {
              console.log('✅ Found existing user by Google ID:', user.id, user.username);
            }
            
            // If not found by Google ID, check by email
            const email = profile.emails?.[0]?.value || "";
            if (!user && email) {
              console.log('Looking up user by email:', email);
              user = await storage.getUserByEmail(email);
              
              // If user exists with this email but no Google ID, update with Google ID
              if (user) {
                console.log('Found user by email, updating with Google ID:', user.id);
                user = await storage.updateUser(user.id, {
                  googleId: profile.id,
                  avatar: profile.photos?.[0]?.value || user.avatar
                });
                console.log('User updated with Google ID:', user.id);
              }
            }
            
            // If pendingUsername is in session, use it
            let pendingUsername = '';
            
            // If still no user, create a new one
            if (!user) {
              console.log('Creating new user from Google profile');
              
              // Get a valid username - try to use display name first
              const displayNameUsername = profile.displayName?.toLowerCase().replace(/\s+/g, ".");
              const username = displayNameUsername || `user${Math.floor(Math.random() * 10000)}`;
              
              console.log('Creating user with username:', username);
              
              user = await storage.createUser({
                username,
                email,
                name: profile.displayName || email.split('@')[0] || 'User',
                googleId: profile.id,
                avatar: profile.photos?.[0]?.value || '',
                password: '', // No password for OAuth users
              });
              
              console.log('Created new user from Google OAuth:', user.id);
              
              // Create default profile
              const newProfile = await storage.createProfile({
                userId: user.id,
                theme: "light",
                backgroundColor: "#7c3aed",
                textColor: "#ffffff",
                fontFamily: "Inter",
                socialLinks: []
              });
              
              console.log('Created profile for new user:', newProfile.id);
            }
            
            console.log('✅ Google OAuth authentication success:', user.id, user.username);
            
            // Return the complete user object to be serialized
            return done(null, user);
          } catch (error) {
            console.error('❌ Error in Google OAuth strategy:', error);
            return done(error as Error, undefined);
          }
        }
      )
    );
  }

  // We already have serialization/deserialization defined above, 
  // so this section is removed to avoid duplication

  // Helper function to handle ZodErrors
  const handleZodError = (error: unknown, res: Response) => {
    if (error instanceof ZodError) {
      const validationError = fromZodError(error);
      return res.status(400).json({ message: validationError.message });
    }
    console.error("Unexpected error:", error);
    return res.status(500).json({ message: "Internal server error" });
  };

  // Authentication Routes
  app.get("/api/auth/google", (req, res, next) => {
    // Store username in session if provided in query param
    if (req.query.username) {
      console.log('📝 Storing pendingUsername in session:', req.query.username);
      req.session.pendingUsername = req.query.username as string;
      
      // Force session save before continuing with authentication
      req.session.save((err) => {
        if (err) {
          console.error('❌ Failed to save pendingUsername to session:', err);
        } else {
          console.log('✅ pendingUsername saved to session:', req.query.username);
          console.log('Current session:', req.session);
        }
        
        // Continue with Google authentication
        passport.authenticate("google", { 
          scope: ["profile", "email"],
          // Add state parameter to pass username through OAuth flow
          state: req.query.username ? JSON.stringify({ pendingUsername: req.query.username }) : undefined
        })(req, res, next);
      });
    } else {
      // No username to store, proceed directly to authentication
      console.log('No username provided in query params');
      passport.authenticate("google", { 
        scope: ["profile", "email"]
      })(req, res, next);
    }
  });

  app.get(
    "/api/auth/google/callback",
    passport.authenticate("google", { failureRedirect: "/" }),
    (req, res) => {
      dumpRequestInfo(req, 'GOOGLE OAUTH CALLBACK');
      
      // Extract state if provided
      const stateParam = req.query.state as string;
      let pendingUsername = '';
      
      if (stateParam) {
        try {
          const stateObj = JSON.parse(stateParam);
          pendingUsername = stateObj.pendingUsername || '';
          console.log('📝 Extracted pendingUsername from state:', pendingUsername);
        } catch (e) {
          console.error('❌ Failed to parse state parameter:', e);
        }
      }
      
      // Also check session for pendingUsername
      if (!pendingUsername && req.session.pendingUsername) {
        pendingUsername = req.session.pendingUsername;
        console.log('📝 Found pendingUsername in session:', pendingUsername);
      }
      
      // Ensure the user object exists
      if (!req.user) {
        console.error("❌ OAuth callback: User object is missing");
        return res.redirect("/?error=authentication_failed");
      }
      
      // Get user ID and save it to session
      const userId = (req.user as any)?.id;
      console.log(`✅ Google OAuth successful for user ID: ${userId}`);
      
      if (!userId) {
        console.error("❌ OAuth callback: User ID is missing");
        return res.redirect("/?error=user_id_missing");
      }
      
      // For debugging - log the session before we modify it
      console.log('Session before modification:', JSON.stringify(req.session, null, 2));
      
      // Ensure req.login is called to properly associate the user with the session
      // This is crucial for Passport.js session handling
      req.login(req.user, { session: true }, (loginErr) => {
        if (loginErr) {
          console.error("❌ Error in req.login():", loginErr);
          return res.redirect("/?error=login_error");
        }
        
        console.log('Session after req.login():', JSON.stringify(req.session, null, 2));
        
        // Update username if we have a pending one
        if (pendingUsername) {
          console.log(`Updating user ${userId} with pendingUsername: ${pendingUsername}`);
          // This will be handled by the frontend callback handler
        }
        
        // Save user ID to session in both formats for redundancy
        req.session.userId = userId;
        if (!req.session.passport) {
          req.session.passport = { user: userId };
        }
        
        // Save pendingUsername as well (as a backup)
        if (pendingUsername) {
          req.session.pendingUsername = pendingUsername;
        }
        
        // Generate JWT token and set as cookie for extra security
        const token = generateToken({
          id: userId,
          email: (req.user as any).email || '',
          username: (req.user as any).username || '',
        });
        
        res.cookie('auth_token', token, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
          maxAge: 7 * 24 * 60 * 60 * 1000, // 1 week
          path: '/'
        });
        
        console.log('Modified session (before save):', JSON.stringify(req.session, null, 2));
        
        // Force session save before redirecting
        req.session.save((err) => {
        if (err) {
          console.error("❌ Failed to save session:", err);
          return res.redirect("/?error=session_save_failed");
        }
        
        console.log(`✅ Session saved successfully with user ID: ${userId}`);
        console.log(`Session cookie:`, req.session.cookie);
        console.log(`Session ID: ${req.sessionID}`);
        
        // Construct redirect URL
        let redirectUrl = "/auth/callback";
        
        // Add username as query param to frontend callback handler if available
        if (pendingUsername) {
          redirectUrl += `?username=${encodeURIComponent(pendingUsername)}`;
        }
        
        // Redirect to frontend callback handler
        console.log(`✅ Redirecting to: ${redirectUrl}`);
        res.redirect(redirectUrl);
      });
    }
  );
  
  // Token endpoint - returns a token for the authenticated user
  // Used during OAuth callback flow - removed authenticateSession middleware to debug
  app.get("/api/auth/token", async (req, res) => {
    try {
      // Use our debug utility
      dumpRequestInfo(req, 'TOKEN ENDPOINT');
      
      // Check if we have a userId in:
      // 1. Session directly
      // 2. Session.passport.user (Passport.js standard)
      let userId = req.session?.userId;
      
      if (!userId && req.session?.passport?.user) {
        userId = req.session.passport.user;
        console.log(`ℹ️ Using userId from passport: ${userId}`);
      }
      
      if (!userId) {
        console.error("❌ No userId in session - direct or passport");
        return res.status(401).json({ message: "Authentication required", details: "No user ID in session" });
      }
      
      console.log(`✅ Found userId in session: ${userId}`);
      
      // Get user from database
      const user = await storage.getUser(userId);
      
      if (!user) {
        console.error(`❌ User with ID ${userId} not found in database`);
        return res.status(404).json({ message: "User not found" });
      }
      
      console.log(`✅ User found: ${user.username} (ID: ${user.id})`);
      
      // Now that we have verified the user, save it properly in the session
      req.session.userId = user.id;
      if (!req.session.passport) {
        req.session.passport = { user: user.id };
      }
      
      // Generate JWT token
      const token = generateToken({
        id: user.id,
        email: user.email,
        username: user.username
      });
      
      console.log(`✅ Generated token for user ID ${user.id}`);
      
      // Set token in cookie as well for redundancy
      res.cookie('auth_token', token, {
        httpOnly: true,
        secure: false, // Set to true in production with HTTPS
        maxAge: 7 * 24 * 60 * 60 * 1000, // 1 week
        path: '/'
      });
      
      // Create response object
      const responseData = { 
        token, 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email,
          name: user.name,
          bio: user.bio || "",
          avatar: user.avatar || ""
        } 
      };
      
      // Save session before sending response to ensure changes are persisted
      req.session.save((err) => {
        if (err) {
          console.error("❌ Error saving session:", err);
          // Still return the data even if session save fails
        } else {
          console.log("✅ Session saved successfully");
        }
        
        // Return response
        res.json(responseData);
      });
    } catch (error) {
      console.error("❌ Error generating token:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // API endpoint to update username after OAuth login
  app.post("/api/auth/update-username", authenticateToken, validateUser, async (req, res) => {
    try {
      const { username } = req.body;
      
      if (!username) {
        return res.status(400).json({ message: "Username is required" });
      }
      
      // Validate username format
      if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
        return res.status(400).json({ 
          message: "Username must be 3-20 characters and only contain letters, numbers, and underscores." 
        });
      }
      
      // Check if username is available
      const existingUser = await storage.getUserByUsername(username);
      
      if (existingUser && existingUser.id !== req.user!.id) {
        return res.status(409).json({ message: "Username is already taken." });
      }
      
      // Update the user's username
      const updatedUser = await storage.updateUser(req.user!.id, { username });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "Failed to update username" });
      }
      
      // Generate JWT token
      const token = generateToken({
        id: updatedUser.id,
        email: updatedUser.email,
        username: updatedUser.username,
      });
      
      res.json({ 
        message: "Username updated successfully", 
        user: {
          id: updatedUser.id,
          username: updatedUser.username,
          email: updatedUser.email,
          name: updatedUser.name,
          avatar: updatedUser.avatar
        },
        token
      });
    } catch (error) {
      console.error("Error updating username:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = userAuthSchema.parse(req.body);
      
      const user = await storage.getUserByEmail(email);
      
      if (!user || user.password !== password) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      
      // Set session
      req.session.userId = user.id;
      
      // Generate JWT token
      const token = generateToken({
        id: user.id,
        email: user.email,
        username: user.username,
      });
      
      res.json({ token, user: { id: user.id, username: user.username, email: user.email } });
    } catch (error) {
      handleZodError(error, res);
    }
  });

  app.post("/api/auth/register", async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if username or email already exists
      const existingUser = await storage.getUserByUsername(userData.username) || 
                          await storage.getUserByEmail(userData.email);
      
      if (existingUser) {
        return res.status(409).json({ message: "Username or email already exists" });
      }
      
      const newUser = await storage.createUser(userData);
      
      // Create default profile
      await storage.createProfile({
        userId: newUser.id,
        theme: "light",
        backgroundColor: "#7c3aed",
        textColor: "#ffffff",
        fontFamily: "Inter",
        socialLinks: []
      });
      
      // Set session
      req.session.userId = newUser.id;
      
      // Generate JWT token
      const token = generateToken({
        id: newUser.id,
        email: newUser.email,
        username: newUser.username,
      });
      
      res.status(201).json({ token, user: { id: newUser.id, username: newUser.username, email: newUser.email } });
    } catch (error) {
      handleZodError(error, res);
    }
  });

  app.post("/api/auth/logout", (req, res) => {
    console.log("🔍 Logout request received");
    console.log("Session before logout:", req.session);
    
    // Clear all session data
    req.session.userId = undefined;
    if (req.session.passport) {
      delete req.session.passport.user;
      delete req.session.passport;
    }
    
    // Destroy the session completely
    req.session.destroy((err) => {
      if (err) {
        console.error("❌ Error destroying session:", err);
        return res.status(500).json({ message: "Failed to logout" });
      }
      
      // Clear the session cookie by setting an expired cookie with the same name
      res.clearCookie('linkybecky.sid', {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax'
      });
      
      console.log("✅ Session successfully destroyed");
      res.json({ message: "Logged out successfully" });
    });
  });

  // Get authenticated user based on JWT token
  app.get("/api/auth/me", authenticateToken, async (req, res) => {
    try {
      console.log("🔍 GET /api/auth/me called with token auth");
      console.log("User from token:", req.user);
      
      const user = await storage.getUser(req.user!.id);
      
      if (!user) {
        console.log(`❌ User with id ${req.user!.id} not found in database`);
        return res.status(404).json({ message: "User not found" });
      }
      
      console.log(`✅ Retrieved user: ${user.username} (ID: ${user.id})`);
      
      res.json({ 
        id: user.id, 
        username: user.username, 
        email: user.email,
        name: user.name,
        bio: user.bio || "",
        avatar: user.avatar || ""
      });
    } catch (error) {
      console.error("❌ Error fetching user:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // Get authenticated user from session (used for session-based auth)
  app.get("/api/auth/me-from-session", async (req, res) => {
    try {
      // Use our debug utility instead of manual logging
      dumpRequestInfo(req, 'ME-FROM-SESSION ENDPOINT');
      
      // Check if we have a userId in:
      // 1. Session directly
      // 2. Session.passport.user (Passport.js standard)
      let userId = req.session?.userId;
      
      if (!userId && req.session?.passport?.user) {
        userId = req.session.passport.user;
        console.log(`ℹ️ Using userId from passport: ${userId}`);
      }
      
      if (!userId) {
        console.error("❌ No userId in session - direct or passport");
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      console.log(`✅ Found userId in session: ${userId}`);
      
      // Get user from database
      const user = await storage.getUser(userId);
      
      if (!user) {
        console.error(`❌ User with ID ${userId} not found in database`);
        return res.status(404).json({ message: "User not found" });
      }
      
      console.log(`✅ Retrieved user: ${user.username} (ID: ${user.id})`);
      
      // Now that we have verified the user, save it properly in the session (both ways)
      req.session.userId = user.id;
      if (!req.session.passport) {
        req.session.passport = { user: user.id };
      }
      
      // Save session with verified user before continuing
      req.session.save((err) => {
        if (err) {
          console.error("❌ Error saving session:", err);
        } else {
          console.log("✅ Session saved successfully with verified user ID");
        }
      });
      
      // Generate a fresh token for the frontend
      const token = generateToken({
        id: user.id,
        email: user.email,
        username: user.username
      });
      
      // Return the user with the token
      res.json({
        id: user.id,
        email: user.email,
        username: user.username,
        name: user.name,
        bio: user.bio || "",
        avatar: user.avatar || "",
        token // Include the token in the response
      });
    } catch (error) {
      console.error("❌ Error in /api/auth/me-from-session:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Username availability check
  app.get("/api/username/availability/:username", async (req, res) => {
    try {
      const { username } = req.params;
      
      // Validate username format
      if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
        return res.status(400).json({ 
          available: false, 
          message: "Username must be 3-20 characters and only contain letters, numbers, and underscores." 
        });
      }
      
      const existingUser = await storage.getUserByUsername(username);
      
      res.json({
        available: !existingUser,
        message: existingUser ? "Username is already taken." : "Username is available."
      });
    } catch (error) {
      console.error("Error checking username availability:", error);
      res.status(500).json({ 
        available: false, 
        message: "Error checking username availability." 
      });
    }
  });

  // User & Profile Routes
  app.get("/api/users/:username", async (req, res) => {
    try {
      const { username } = req.params;
      const user = await storage.getUserByUsername(username);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const profile = await storage.getProfile(user.id);
      const userLinks = await storage.getLinks(user.id);
      
      // Filter out disabled links for public profile
      const enabledLinks = userLinks.filter(link => link.enabled);
      
      res.json({
        username: user.username,
        name: user.name,
        bio: user.bio,
        avatar: user.avatar,
        profile,
        links: enabledLinks
      });
    } catch (error) {
      console.error("Error fetching user profile:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/profile", authenticateToken, validateUser, async (req, res) => {
    try {
      const profile = await storage.getProfile(req.user!.id);
      
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      
      res.json(profile);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.put("/api/profile", authenticateToken, validateUser, async (req, res) => {
    try {
      // Add debugging to understand auth issues in production
      console.log('PUT /api/profile - User info:', {
        userId: req.user?.id,
        username: req.user?.username,
        authenticated: !!req.user
      });
      console.log('Request headers:', {
        authorization: req.headers.authorization ? 'Present (not shown)' : 'Missing',
        cookie: req.headers.cookie ? 'Present (not shown)' : 'Missing',
        'content-type': req.headers['content-type']
      });
      
      if (!req.user) {
        console.error('❌ User authentication failed for PUT /api/profile');
        return res.status(401).json({ message: 'Authentication required' });
      }
      
      const profileData = insertProfileSchema.partial().parse(req.body);
      console.log('Updating profile with data:', profileData);
      
      const profile = await storage.getProfile(req.user.id);
      
      if (!profile) {
        console.log('No existing profile found, creating new profile');
        // Create profile if not exists
        const newProfile = await storage.createProfile({
          ...profileData,
          userId: req.user.id
        });
        console.log('Created new profile:', newProfile.id);
        return res.json(newProfile);
      }
      
      console.log('Updating existing profile:', profile.id);
      // Update existing profile
      const updatedProfile = await storage.updateProfile(req.user.id, profileData);
      console.log('Profile updated successfully');
      res.json(updatedProfile);
    } catch (error) {
      console.error('Error updating profile:', error);
      handleZodError(error, res);
    }
  });

  // Link Routes
  app.get("/api/links", authenticateToken, validateUser, async (req, res) => {
    try {
      const links = await storage.getLinks(req.user!.id);
      res.json(links);
    } catch (error) {
      console.error("Error fetching links:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/links", authenticateToken, validateUser, async (req, res) => {
    try {
      // Add debugging to understand auth issues in production
      console.log('POST /api/links - User info:', {
        userId: req.user?.id,
        username: req.user?.username,
        authenticated: !!req.user
      });
      console.log('Request headers:', {
        authorization: req.headers.authorization ? 'Present (not shown)' : 'Missing',
        cookie: req.headers.cookie ? 'Present (not shown)' : 'Missing',
        'content-type': req.headers['content-type']
      });
      
      if (!req.user) {
        console.error('❌ User authentication failed for POST /api/links');
        return res.status(401).json({ message: 'Authentication required' });
      }
      
      const linkData = insertLinkSchema.parse(req.body);
      console.log('Creating new link with data:', {...linkData, url: linkData.url?.substring(0, 30) + '...'});
      
      // Get current max position
      const links = await storage.getLinks(req.user.id);
      const maxPosition = links.length > 0 
        ? Math.max(...links.map(link => link.position))
        : -1;
      
      // Create link with next position
      const newLink = await storage.createLink({
        ...linkData,
        userId: req.user.id,
        position: maxPosition + 1
      });
      
      // Shorten the URL if not already shortened
      if (!newLink.shortUrl) {
        try {
          const { shortUrl } = await shortenUrl(newLink.url);
          await storage.updateLink(newLink.id, { shortUrl });
          newLink.shortUrl = shortUrl;
        } catch (error) {
          console.error("Error shortening URL:", error);
          // Continue even if shortening fails
        }
      }
      
      res.status(201).json(newLink);
    } catch (error) {
      handleZodError(error, res);
    }
  });

  app.get("/api/links/:id", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const link = await storage.getLink(parseInt(id));
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      // Check if link belongs to the authenticated user
      if (link.userId !== req.user!.id) {
        return res.status(403).json({ message: "Unauthorized access to link" });
      }
      
      res.json(link);
    } catch (error) {
      console.error("Error fetching link:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.put("/api/links/:id", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const linkId = parseInt(id);
      
      const link = await storage.getLink(linkId);
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      // Check if link belongs to the authenticated user
      if (link.userId !== req.user!.id) {
        return res.status(403).json({ message: "Unauthorized access to link" });
      }
      
      const linkData = insertLinkSchema.partial().parse(req.body);
      
      // Check if URL changed and needs reshortening
      if (linkData.url && linkData.url !== link.url) {
        try {
          // Add UTM parameters if specified
          let urlToShorten = linkData.url;
          
          if (linkData.utmSource || linkData.utmMedium || linkData.utmCampaign) {
            urlToShorten = addUtmParameters(urlToShorten, {
              source: linkData.utmSource,
              medium: linkData.utmMedium,
              campaign: linkData.utmCampaign,
              term: linkData.utmTerm,
              content: linkData.utmContent
            });
          }
          
          const { shortUrl } = await shortenUrl(urlToShorten);
          linkData.shortUrl = shortUrl;
        } catch (error) {
          console.error("Error shortening URL:", error);
          // Continue even if shortening fails
        }
      }
      
      const updatedLink = await storage.updateLink(linkId, linkData);
      res.json(updatedLink);
    } catch (error) {
      handleZodError(error, res);
    }
  });

  app.delete("/api/links/:id", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const linkId = parseInt(id);
      
      const link = await storage.getLink(linkId);
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      // Check if link belongs to the authenticated user
      if (link.userId !== req.user!.id) {
        return res.status(403).json({ message: "Unauthorized access to link" });
      }
      
      const result = await storage.deleteLink(linkId);
      
      if (result) {
        res.json({ message: "Link deleted successfully" });
      } else {
        res.status(500).json({ message: "Failed to delete link" });
      }
    } catch (error) {
      console.error("Error deleting link:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/links/reorder", authenticateToken, validateUser, async (req, res) => {
    try {
      const linkPositions = z.array(linkUpdatePositionSchema).parse(req.body);
      
      const result = await storage.updateLinkPositions(req.user!.id, linkPositions);
      
      if (result) {
        res.json({ message: "Link positions updated successfully" });
      } else {
        res.status(500).json({ message: "Failed to update link positions" });
      }
    } catch (error) {
      handleZodError(error, res);
    }
  });

  // QR Code Generation
  app.get("/api/links/:id/qrcode", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const link = await storage.getLink(parseInt(id));
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      // Check if link belongs to the authenticated user
      if (link.userId !== req.user!.id) {
        return res.status(403).json({ message: "Unauthorized access to link" });
      }
      
      const url = link.shortUrl || link.url;
      const qrCodeUrl = await generateQrCode(url);
      
      res.json({ qrCodeUrl });
    } catch (error) {
      console.error("Error generating QR code:", error);
      res.status(500).json({ message: "Failed to generate QR code" });
    }
  });

  // Analytics Routes
  app.get("/api/analytics", authenticateToken, validateUser, async (req, res) => {
    try {
      const { period } = req.query;
      const analytics = await storage.getAnalytics(req.user!.id, period as string);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/links/:id/analytics", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const { period } = req.query;
      
      const link = await storage.getLink(parseInt(id));
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      // Check if link belongs to the authenticated user
      if (link.userId !== req.user!.id) {
        return res.status(403).json({ message: "Unauthorized access to link" });
      }
      
      // If the link has a shortUrl, get analytics from LinkyVicky
      if (link.shortUrl) {
        try {
          const shortUrlId = link.shortUrl.split('/').pop();
          const analytics = await getUrlAnalytics(shortUrlId!, period as string);
          return res.json(analytics);
        } catch (error) {
          console.error("Error fetching analytics from LinkyVicky:", error);
          // Fall back to local analytics if LinkyVicky fails
        }
      }
      
      // Fallback to local analytics
      const analytics = await storage.getLinkAnalytics(parseInt(id), period as string);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching link analytics:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Record click
  app.post("/api/links/:id/click", async (req, res) => {
    try {
      const { id } = req.params;
      const { country, device, browser } = req.body;
      
      const link = await storage.getLink(parseInt(id));
      
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      
      await storage.recordClick({
        linkId: parseInt(id),
        userId: link.userId,
        clicks: 1,
        country,
        device,
        browser
      });
      
      res.json({ message: "Click recorded successfully" });
    } catch (error) {
      console.error("Error recording click:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // AI Routes
  app.post("/api/ai/link-suggestions", authenticateToken, validateUser, async (req, res) => {
    try {
      const { url } = req.body;
      
      if (!url) {
        return res.status(400).json({ message: "URL is required" });
      }
      
      const suggestions = await generateLinkSuggestions(url);
      res.json(suggestions);
    } catch (error) {
      console.error("Error generating link suggestions:", error);
      res.status(500).json({ message: "Failed to generate suggestions" });
    }
  });

  app.get("/api/ai/insights", authenticateToken, validateUser, async (req, res) => {
    try {
      const insights = await storage.getAiInsights(req.user!.id);
      res.json(insights);
    } catch (error) {
      console.error("Error fetching AI insights:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/ai/insights/:id/seen", authenticateToken, validateUser, async (req, res) => {
    try {
      const { id } = req.params;
      const result = await storage.markAiInsightAsSeen(parseInt(id));
      
      if (result) {
        res.json({ message: "Insight marked as seen" });
      } else {
        res.status(404).json({ message: "Insight not found" });
      }
    } catch (error) {
      console.error("Error marking insight as seen:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/ai/link-order", authenticateToken, validateUser, async (req, res) => {
    try {
      const { links } = req.body;
      
      if (!links || !Array.isArray(links)) {
        return res.status(400).json({ message: "Links array is required" });
      }
      
      const recommendations = await generateLinkOrderRecommendations(links);
      res.json(recommendations);
    } catch (error) {
      console.error("Error generating link order recommendations:", error);
      res.status(500).json({ message: "Failed to generate recommendations" });
    }
  });

  // Add a catch-all route to handle user profile URLs in the format /@username
  // This should be the LAST route before returning the httpServer
  app.get('/@:username', (req, res, next) => {
    console.log(`Caught request for user profile: @${req.params.username}`);
    
    // In development mode, let Vite handle this
    if (process.env.NODE_ENV === 'development') {
      return next();
    }
    
    // In production, we need to manually serve the index.html file
    try {
      const distPath = path.resolve(import.meta.dirname, "public");
      console.log(`Serving index.html from ${distPath} for profile @${req.params.username}`);
      return res.sendFile(path.resolve(distPath, "index.html"));
    } catch (error) {
      console.error('Error serving index.html for profile page:', error);
      next(error);
    }
  });

  return httpServer;
}
)

  return httpServer;
}